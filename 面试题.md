# 面试宝典
#### 基础篇

##### 1、了解大部分数组处理函数
```
array() 创建数组。
array_change_key_case() 把数组中所有键更改为小写或大写。
array_chunk() 把一个数组分割为新的数组块。
array_column() 返回输入数组中某个单一列的值。
array_combine() 通过合并两个数组来创建一个新数组。
array_count_values() 用于统计数组中所有值出现的次数。
array_diff() 比较数组，返回差集（只比较键值）。
array_diff_assoc() 比较数组，返回差集（比较键名和键值）。
array_diff_key() 比较数组，返回差集（只比较键名）。
array_diff_uassoc() 比较数组，返回差集（比较键名和键值，使用用户自定义的键名比较函数）。
array_diff_ukey() 比较数组，返回差集（只比较键名，使用用户自定义的键名比较函数）。
array_fill() 用给定的键值填充数组。
array_fill_keys() 用指定键名的给定键值填充数组。
array_filter() 用回调函数过滤数组中的元素。
array_flip() 交换数组中的键和值。
array_intersect() 比较数组，返回交集（只比较键值）。
array_intersect_assoc() 比较数组，返回交集（比较键名和键值）。
array_intersect_key() 比较数组，返回交集（只比较键名）。
array_intersect_uassoc() 比较数组，返回交集（比较键名和键值，使用用户自定义的键名比较函数）。
array_intersect_ukey() 比较数组，返回交集（只比较键名，使用用户自定义的键名比较函数）。
array_key_exists() 检查指定的键名是否存在于数组中。
array_keys() 返回数组中所有的键名。
array_map() 把数组中的每个值发送到用户自定义函数，返回新的值。
array_merge() 把一个或多个数组合并为一个数组。
array_merge_recursive() 递归地合并一个或多个数组。
array_multisort() 对多个数组或多维数组进行排序。
array_pad() 用值将数组填补到指定长度。
array_pop() 删除数组的最后一个元素（出栈）。
array_product() 计算数组中所有值的乘积。
array_push() 将一个或多个元素插入数组的末尾（入栈）。
array_rand() 返回数组中一个或多个随机的键。
array_reduce() 通过使用用户自定义函数，以字符串返回数组。
array_replace() 使用后面数组的值替换第一个数组的值。
array_replace_recursive() 递归地使用后面数组的值替换第一个数组的值。
array_reverse() 以相反的顺序返回数组。
array_search() 搜索数组中给定的值并返回键名。
array_shift() 删除数组中首个元素，并返回被删除元素的值。
array_slice() 返回数组中被选定的部分。
array_splice() 删除并替换数组中指定的元素。
array_sum() 返回数组中值的和。
array_udiff() 比较数组，返回差集（只比较值，使用一个用户自定义的键名比较函数）。
array_udiff_assoc() 比较数组，返回差集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。
array_udiff_uassoc() 比较数组，返回差集（比较键和值，使用两个用户自定义的键名比较函数）。
array_uintersect() 比较数组，返回交集（只比较值，使用一个用户自定义的键名比较函数）。
array_uintersect_assoc() 比较数组，返回交集（比较键和值，使用内建函数比较键名，使用用户自定义函数比较键值）。
array_uintersect_uassoc() 比较数组，返回交集（比较键和值，使用两个用户自定义的键名比较函数）。
array_unique() 删除数组中的重复值。
array_unshift() 在数组开头插入一个或多个元素。
array_values() 返回数组中所有的值。
array_walk() 对数组中的每个成员应用用户函数。
array_walk_recursive() 对数组中的每个成员递归地应用用户函数。
arsort() 对关联数组按照键值进行降序排序。
asort() 对关联数组按照键值进行升序排序。
compact() 创建包含变量名和它们的值的数组。
count() 返回数组中元素的数目。
current() 返回数组中的当前元素。
each() 返回数组中当前的键／值对。
end() 将数组的内部指针指向最后一个元素。
extract() 从数组中将变量导入到当前的符号表。
in_array() 检查数组中是否存在指定的值。
key() 从关联数组中取得键名。
krsort() 对数组按照键名逆向排序。
ksort() 对数组按照键名排序。
list() 把数组中的值赋给一些变量。
natcasesort() 用“自然排序”算法对数组进行不区分大小写字母的排序。
natsort() 用“自然排序”算法对数组排序。
next() 将数组中的内部指针向前移动一位。
pos() current() 的别名。
prev() 将数组的内部指针倒回一位。
range() 创建包含指定范围单元的数组。
reset() 将数组的内部指针指向第一个元素。
rsort() 对数组逆向排序。
shuffle() 将数组打乱。
sizeof() count() 的别名。
sort() 对数组排序。
uasort() 使用用户自定义的比较函数对数组中的键值进行排序。
uksort() 使用用户自定义的比较函数对数组中的键名进行排序。
usort() 使用用户自定义的比较函数对数组进行排序。
```
##### 2、字符串处理函数 区别 `mb_` 系列函数
```
mb_check_encoding — 检查字符串在指定的编码里是否有效
mb_convert_case — 对字符串进行大小写转换
mb_convert_encoding — 转换字符的编码
mb_convert_variables — 转换一个或多个变量的字符编码
mb_decode_mimeheader — 解码 MIME 头字段中的字符串
mb_decode_numericentity — 根据 HTML 数字字符串解码成字符
mb_detect_encoding — 检测字符的编码
mb_detect_order — 设置/获取 字符编码的检测顺序
mb_encode_mimeheader — 为 MIME 头编码字符串
mb_get_info — 获取 mbstring 的内部设置
mb_http_input — 检测 HTTP 输入字符编码
mb_http_output — 设置/获取 HTTP 输出字符编码
mb_internal_encoding — 设置/获取内部字符编码
mb_language — 设置/获取当前的语言
mb_list_encodings — 返回所有支持编码的数组
mb_output_handler — 在输出缓冲中转换字符编码的回调函数
mb_parse_str — 解析 GET/POST/COOKIE 数据并设置全局变量
mb_preferred_mime_name — 获取 MIME 字符串
mb_send_mail — 发送编码过的邮件
mb_split — 使用正则表达式分割多字节字符串
mb_strcut — 获取字符的一部分
mb_strimwidth — 获取按指定宽度截断的字符串
mb_stripos — 大小写不敏感地查找字符串在另一个字符串中首次出现的位置
mb_stristr — 大小写不敏感地查找字符串在另一个字符串里的首次出现
mb_strlen — 获取字符串的长度
mb_strpos — 查找字符串在另一个字符串中首次出现的位置
mb_strrchr — 查找指定字符在另一个字符串中最后一次的出现
mb_strrichr — 大小写不敏感地查找指定字符在另一个字符串中最后一次的出现
mb_strripos — 大小写不敏感地在字符串中查找一个字符串最后出现的位置
mb_strrpos — 查找字符串在一个字符串中最后出现的位置
mb_strstr — 查找字符串在另一个字符串里的首次出现
mb_strtolower — 使字符串小写
mb_strtoupper — 使字符串大写
mb_strwidth — 返回字符串的宽度
mb_substitute_character — 设置/获取替代字符
mb_substr_count — 统计字符串出现的次数
mb_substr — 获取部分字符串
```
##### 3、& 引用，结合案例分析
```
    $a = "ABC";
    $b = &$a;
    echo $a;//这里输出:ABC
    echo $b;//这里输出:ABC
    $b = "EFG";
    echo $a;//这里$a的值变为EFG 所以输出EFG
    echo $b;//这里输出EFG
```
##### 4、`==` 与 `===` 区别
```
== 只对值比较，=== 会对值和类型进行比较

$a = 0;
$b = 'test';
if ($a == $b) {
    echo 'true';
} else {
    echo 'false';
}
// 结果为 true ，数字与非数字比较时会先将非数字转换为0，再和数字比较

if ($a === $b) {
    echo 'true';
} else {
    echo 'false';
}
// 结果为false ，比较类型和结果，同时满足则等式成立

```
##### 5、`isset` 与 `empty` 区别
```
isset 判断变量是否设置
empty 判断变量是否为空
```
##### 6、全部魔术函数理解
```
1、__construct()
实例化对象时被调用，当__construct和以类名为函数名的函数同时存在时，__construct将被调用，另一个不被调用。

2、__destruct()
当删除一个对象或对象操作终止时被调用。

3、__call()
对象调用某个方法， 若方法存在，则直接调用； 若不存在，则会去调用__call函数。

4、__get()
读取一个对象的属性时， 若属性存在，则直接返回属性值； 若不存在，则会调用__get函数。

5、__set()
设置一个对象的属性时， 若属性存在，则直接赋值； 若不存在，则会调用__set函数。

6、__toString()
打印一个对象的时被调用。如echo $obj;或print $obj;

7、__clone()
克隆对象时被调用。如：$t=new Test();$t1=clone $t;

8、__sleep()
serialize之前被调用。若对象比较大，想删减一点东东再序列化，可考虑一下此函数。

9、__wakeup()
unserialize时被调用，做些对象的初始化工作。

10、__isset()
检测一个对象的属性是否存在时被调用。如：isset($c->name)。

11、__unset()
unset一个对象的属性时被调用。如：unset($c->name)。

12、__set_state()
调用var_export时，被调用。用__set_state的返回值做为var_export的返回值。

13、__autoload()
实例化一个对象时，如果对应的类不存在，则该方法被调用。
```
##### 7、`static`、`$this`、`self` 区别
```
self 和 __CLASS__，都是对当前类的静态引用，取决于定义当前方法所在的类。也就是说，self 写在哪个类里面， 它引用的就是谁。
self 可以用于访问类的静态属性、静态方法和常量，但 self 指向的是当前定义所在的类，这是 self 的限制。
$this 指向的是实际调用时的对象，也就是说，实际运行过程中，谁调用了类的属性或方法，$this 指向的就是哪个对象。但 $this 不能访问类的静态属性和常量，且 $this 不能存在于静态方法中。
$this 指向的对象所属的类和 static 指向的类相同。
static 关键字除了可以声明类的静态成员（属性和方法）外，还有一个非常重要的作用就是后期静态绑定。
static 可以用于静态或非静态方法中，也可以访问类的静态属性、静态方法、常量和非静态方法，但不能访问非静态属性。
静态调用时，static 指向的是实际调用时的类；非静态调用时，static 指向的是实际调用时的对象所属的类。

```
##### 8、`private`、`protected`、`public`、`final` 区别
```
1、public 表示全局，类内部外部子类都可以访问。
2、private 表示私有的，只有本类内部可以使用。
3、protected 表示受保护的，只有本类或子类或父类中可以访问。
4、final 定义不可重复的方法
```
##### 9、`OOP` 思想
```
面向对象的三大特征：封装、继承、多态
1、封装 ： 一个类可以有一些私有属性或方法，可以把一些解决问题的方法封装起来，对外只提供接口，通过调用接口可以解决问题，但是外部并不知道具体的解决方法是什么
2、继承 ： 一个类的属性可以被多个类继承，但是一个子类只能有一个父类，一个父类可以有多个子类
3、多态 ： 父类中定义的属性被子类继承后可以具有不同的数据类型或者表现出不同的行为
```
##### 10、抽象类、接口 分别使用场景
```
1、抽象方法是作为子类摸版使用的，抽象类不能被实力话，一个抽象类中，必须有一个抽象方法。但是抽象类中可以定义动态函数。
2、一个类继承了一个接口后将覆盖接口的所有方法，接口只能定义常量，接口里只能定义公有方法，否则无法被继承。
```
##### 11、`Trait` 是什么东西
##### 12、`echo`、`print`、`printf`、`print_r` 区别(区分出表达式与语句的区别)
```
1、echo：可以同时输出多个值，是语言结构，是php内部的指令，不能作为表达式的一部分使用,不是函数
2、print：是输出int或string的函数，有值返回true，否则false
3、printf: 输出格式化字符串的函数
4、print_r: 可以输出字符串和数组的函数
5、var_dump: 可以输出变量类型和长度，便与调试
6、表达式 ： 任何有值的东西，如变量、常量
7、语句：由一些表达式组成的，未完成某项任务的就是语句，如if语句，swich语句
```
##### 13、`__construct` 与 `__destruct` 区别
```
1、__construct：构造函数，对象被创建后第一个被自动调用的方法，用于对成员的属性在创建对象时初始赋值
2、__destruct：析构函数，对象的所有引用都被删除时自动调用的方法，目的不是销毁，而是关闭资源连接，释放内存
```
##### 14、`__toString()` 作用
```
1、__toString()是快速获取对象的字符串信息的便捷方式，直接输出对象引用则自动调用了对象中的__toString()方法
```
##### 15、单引号'与双引号"区别
```
1、双引号内部的变量会解析，单引号不会
2、双引号内部可包含变量，单引号只能包含字符串
3、双引号中的变量和特殊字符会被转译，单引号不会
4、在无变量情况下使用单引号效率更高

```
##### 16、常见 `HTTP` 状态码，分别代表什么含义
```
2xx （3种）

1、200 OK：表示从客户端发送给服务器的请求被正常处理并返回；

2、204 No Content：表示客户端发送给客户端的请求得到了成功处理，但在返回的响应报文中不含实体的主体部分（没有资源可以返回）；

3、206 Patial Content：表示客户端进行了范围请求，并且服务器成功执行了这部分的GET请求，响应报文中包含由Content-Range指定范围的实体内容。

3xx （5种）

1、301 Moved Permanently：永久性重定向，表示请求的资源被分配了新的URL，之后应使用更改的URL；

2、302 Found：临时性重定向，表示请求的资源被分配了新的URL，希望本次访问使用新的URL；

3、301与302的区别：前者是永久移动，后者是临时移动（之后可能还会更改URL）

4、303 See Other：表示请求的资源被分配了新的URL，应使用GET方法定向获取请求的资源；

5、 302与303的区别：后者明确表示客户端应当采用GET方式获取资源

6、304 Not Modified：表示客户端发送附带条件（是指采用GET方法的请求报文中包含if-Match、If-Modified-Since、If-None-Match、If-Range、If-Unmodified-Since中任一首部）的请求时，服务器端允许访问资源，但是请求为满足条件的情况下返回改状态码；

7、307 Temporary Redirect：临时重定向，与303有着相同的含义，307会遵照浏览器标准不会从POST变成GET；（不同浏览器可能会出现不同的情况）；

4xx （4种）

1、400 Bad Request：表示请求报文中存在语法错误；

2、401 Unauthorized：未经许可，需要通过HTTP认证；

3、403 Forbidden：服务器拒绝该次访问（访问权限出现问题）

4、404 Not Found：表示服务器上无法找到请求的资源，除此之外，也可以在服务器拒绝请求但不想给拒绝原因时使用；

5xx （2种）

1、500 Inter Server Error：表示服务器在执行请求时发生了错误，也有可能是web应用存在的bug或某些临时的错误时；

2、503 Server Unavailable：表示服务器暂时处于超负载或正在进行停机维护，无法处理请求；
```
#### 进阶篇

##### 1、`Autoload、Composer` 原理 PSR-4 、原理
##### 2、`Session` 共享、存活时间
```
较大的网站都会使用多条子域名，如果这些子域名需要共用用户登录信息时就需要共享session，有两种解决方案：
1、多台服务器用同一个session_id
    a. 这个比较容易解决，只要在php中设置存session_id的cookie域名为网站主域就可以
    b. 打开PHP.ini， 设置session.cookie_domain = .feiniu.com, 
    c. 当然也可以在php代码当中设置ini_set("session.cookie_domain","feiniu.com");
2、多台服务器用同一个session_id访问到相同的session内容 
    a. 要实现这点，就必须把session内容存储到让所有服务器都能访问到的地方，php的session内容是默认存储到本服务器的文件中的，
    b. 一般的解决方案是存入数据库，memcache或者redis这种缓存服务器，当然用默认的文件存储方式也可以，用NFS统一存储。
    c. 如何修改session存储引擎，参考这篇文章：http://blog.csdn.net/yagas/article/details/7593415
```
##### 3、异常处理
```
set_exception_handler — 设置用户自定义的异常处理函数

使用 try / catch 捕获
```
##### 4、如何 `foreach` 迭代对象
##### 5、如何数组化操作对象 `$obj[key];`
##### 6、如何函数化对象 `$obj(123);`
##### 7、`yield` 是什么，说个使用场景 yield
##### 8、`PSR` 是什么，`PSR-1, 2, 4, 7`
##### 9、如何获取`客户端 IP` 和`服务端 IP` 地址
```
客户端IP: $_SERVER['REMOTE_ADDR']

服务端IP: $_SERVER['SERVER_ADDR']

客户端IP(代理透传): $_SERVER['HTTP_X_FORWARDED_FOR']
    
```
##### 10、如何开启 `PHP` 异常提示

- 配置选项

|名字|默认|备注|
|-|-|-|
|short_open_tag|"1"|是否开启缩写形式(`<? ?>`)|
|precision|"14"|浮点数中显示有效数字的位数|
|disable_functions|""|禁止某些函数|
|disable_classes|""|禁用某些类|
|expose_php|""|是否暴露 PHP 被安装在服务器上|
|max_execution_time|30|最大执行时间|
|memory_limit|128M|每个脚本执行的内存限制|
|error_reporting|NULL|设置错误报告的级别 `E_ALL` & ~`E_NOTICE` & ~`E_STRICT` & ~`E_DEPRECATED`|
|display_errors|"1"|显示错误|
|log_errors|"0"|设置是否将错误日志记录到 error_log 中|
|error_log|NULL|设置脚本错误将被记录到的文件|
|upload_max_filesize|"2M"|最大上传文件大小|
|post_max_size|"8M"|设置POST最大数据限制|

- 运行时，使用 `ini_set(k, v);` 动态设置
```
ini_set('date.timezone', 'Asia/Shanghai'); //设置时区
ini_set('display_errors', '1'); //设置显示错误
ini_set('memory_limit', '256M'); //设置最大内存限制
```
##### 11、如何返回一个`301`重定向 
- [WARNING] 一定当心设置 `301` 后脚本会继续执行，不要认为下面不会执行，必要时使用 die or exit
##### 12、如何获取扩展安装路径
- `phpinfo();` 页面查找 `extension_dir`
- 命令行 `php -i |grep extension_dir`
- 运行时 `echo ini_get('extension_dir');`
##### 13、字符串、数字比较大小的原理，注意 0 开头的8进制、0x 开头16进制
- 字符串比较大小，从左(高位)至右，逐个字符 `ASCII` 比较
##### 14、BOM 头是什么，怎么除去
```
BOM是用来判断文本文件是哪一种Unicode编码的标记，其本身是一个Unicode字符（"\uFEFF"），位于文本文件头部。
使用notepad++的时候选择设置无BOM头的UTF8编码或者使用 header(“content-type:text/html; charset=utf-8”);
```
- 0xEF,0xBB,0xBF
- 检测、去除
##### 15、什么是 `MVC`
```
MVC 包括三类对象。
模型 Model 是应用对象，
视图 View 是它在屏幕上的表示，
控制器 Controller 定义用户界面对用户输入的响应方式。
不使用 MVC，用户界面设计往往将这些对象混在一起，而 MVC 则将它们分离以提高灵活性和复用性

```
##### 16、依赖注入实现原理
##### 17、如何异步执行命令
##### 18、模板引擎是什么，解决什么问题、实现原理（Smarty、Twig、Blade）
##### 19、如何实现链式操作 `$obj->w()->m()->d();`
##### 20、`Xhprof` 、`Xdebug` 性能调试工具使用
##### 21、索引数组 `[1, 2]` 与关联数组 `['k1'=>1, 'k2'=>2]` 有什么区别
##### 22、缓存的使用方式、场景
#### 实践篇

##### 1、给定二维数组，根据某个字段排序
```
$last_names = array_column($arr,'字段名');
array_multisort($last_names,SORT_DESC,$arr);
```
##### 2、如何判断上传文件类型，如：仅允许 `jpg` 上传
```
$info = $_FILES['file']['name'];            //得到文件的名称
$temp = explode('.', $info);                //用.分割数组
$imgtype = end($temp);                      //取数组的最后一个
$filetype = ['jpg', 'jpge', 'gif', 'png'];  //定义图片类型
if (!in_array($imgtype, $filetype)) {
    echo '对不起您没有上传指定的类型';
} else {
    echo '上传成功';
}
```
##### 3、不使用临时变量交换两个变量的值 `$a=1; $b=2; => $a=2; $b=1;`
```
list($b,$a) = [$a,$b];
echo $a;
echo $b;
```
##### 4、`strtoupper` 在转换中文时存在乱码，你如何解决？`php echo strtoupper('ab你好c')`;
```
改用 mb_strtoupper('ab你好c');
```
##### 5、`Websocket、Long-Polling、Server-Sent Events(SSE)` 区别
##### 6、`"Headers already sent" `错误是什么意思，如何避免
```
<?php之前不得有任何内容，包括空白、空行
```
#### 算法篇

##### 1、快速排序（手写）
```
function quick_sort($array) {
     if(count($array) <= 1) return $array;
     $key = $array[0];
     $rightArray = array();
     $leftArray = array();
     for($i = 1; $i < count($array); $i++) {
               if($array[$i] >= $key) {
      $rightArray[] = $array[$i];
        } else {
      $leftArray[] = $array[$i];
        }
     }
     $leftArray = quick_sort($leftArray);
     $rightArray = quick_sort($rightArray);
     return array_merge($leftArray, array($key), $rightArray);
}
```
##### 2、冒泡排序（手写）
```
$data = [4,2,5,3,2,88,1,0,7];
$num = count($data);
for ($i = 0;$i < $num;$i++) {
    for ($j = 0;$j < $num -1;$j++) {
        if （$data[$j] > $data[$j + 1] ) list($data[$j],$data[$j+1]) = [$data[$j+1],$data[$j]];
    }
}
print_r($data);
```
##### 3、['a'=>200,'b'=>100,'c'=>100],写一个自定义排序函数，按值降序,如果值一样，按键排序
```
function kvsort($arr) {
    $res_arr = [];
    while (count($arr)) {
        $min = null;
        $min_key = null;

        foreach ($arr as $key=>$value) {
            if(!$min || $min > $value) {
                $min = $value;
                $min_key = $key;
            } else if($min == $value && $min_key > $key) {
                $min = $value;
                $min_key = $key;
            }
        }
        unset($arr[$min_key]);
        $res_arr[$min_key] = $min;
    }
    return $res_arr;
}
```
##### 3、二分查找（了解）
```
// 查找所需要的元素的位置
function find($array, $low, $high, $k){
      if ($low <= $high){
      $mid = intval(($low+$high)/2);
      if ($array[$mid] == $k){
        return $mid;
      } elseif ($k < $array[$mid]){
        return find($array, $low, $mid-1, $k);
      } else {
        return find($array, $mid+1, $high, $k);
      }
  }
  die('Not have...');
}
//test
$array = array(2,4,3,5);
$n = count($array);
$r = find($array,0,$n,5)
```
##### 4、查找算法 `KMP`（了解）
##### 5、深度、广度优先搜索（了解）
##### 6、`LRU` 缓存淘汰算法（了解，`Memcached` 采用该算法）
##### 7、数据结构篇（了解）

##### 8、堆、栈特性
##### 9、队列
##### 10、哈希表
##### 11、链表
##### 12、请写出自少两个获取指定文件夹下所有文件的方法
```
//递归
function readDirDeep($path,$deep = 0)
{
    $handle = opendir($path);
    while(false !== ($filename = readdir($handle))){
        if($filename == '.' || $filename == '..') continue;
        echo str_repeat('&nbsp;',$deep*5) . $filename.'<br>';
            //str_repeat(str,n) 重复一个str字符串n次
        if(is_dir($path.'/'.$filename)){
            readDirDeep($path.'/'.$filename,$deep+1);
            }
        }
        //闭关
        closedir($handle);
}

//队列
队列的方式就是遇到目录就放入队列,非目录打印就好
function readDirQueue($dir)
{
    $dirs = [$dir];

    while ($path = array_shift($dirs)) {
        if (is_dir($path) && $handle = opendir($path)) {
            while (false !== ($filename = readdir($handle))) {
                if ($filename == '.' || $filename == '..') continue;
                $real_path = $path . DIRECTORY_SEPARATOR . $filename;

                if(is_dir($real_path)) {
                    $dirs[] = $real_path;
                }else {
                    echo $real_path . '<br/>';
                }
            }
            //闭关
            closedir($handle);
        }
    }

}
```
#### 对比篇

##### 1、`Cookie` 与 `Session` 区别
```
1、存储位置不同
cookie的数据信息存放在客户端浏览器上。
session的数据信息存放在服务器上。

2、存储容量不同
单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie。
对于session来说并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且设置session删除机制。

3、存储方式不同
cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据。
session中能够存储任何类型的数据，包括且不限于string，integer，list，map等。

4、隐私策略不同
cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗，所以它是不安全的。
session存储在服务器上，对客户端是透明对，不存在敏感信息泄漏的风险。

5、有效期上不同
开发可以通过设置cookie的属性，达到使cookie长期有效的效果。
session依赖于名为JSESSIONID的cookie，而cookie JSESSIONID的过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果。

6、服务器压力不同
cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择。
session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存。

7、浏览器支持不同
假如客户端浏览器不支持cookie：

cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了。
运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效。

假如客户端支持cookie：

cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效。
session只能在本窗口以及子窗口内有效。

8、跨域支持上不同
cookie支持跨域名访问。
session不支持跨域名访问。
```
##### 2、`GET` 与 `POST` 区别
```
1.GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符

2.GET： 传送的数据量较小，不能大于2KB。post 传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 用IIS过滤器的只接受get参数，所以一般大型搜索引擎都是用get方式

3.GET:是从服务器上获取数据，post 是向服务器传送数据。 get 请求返回 request – URI 所指出的任意信息。

4.GET:是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。post是通过HTTP post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址，用户看不到这个过程。

5.POST：一般用于修改服务器上的资源，对所发送的信息没有限制。

6.GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值，也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。

然而，在以下情况中，请使用 POST 请求：

无法使用缓存文件（更新服务器上的文件或数据库）

向服务器发送大量数据（POST 没有数据量限制）

发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠
```
##### 3、`include` 与 `require` 区别
```
1、加载失败的处理方式不同
include与require除了在处理引入文件的方式不同外，最大的区别就是：
include在引入不存文件时产生一个警告且脚本还会继续执行，
require则会导致一个致命性错误且脚本停止执行。

2、include()是有条件包含函数，而 require()则是无条件包含函数。

3、include有返回值，而require没有

4、include()执行时需要引用的文件每次都要进行读取和评估,而require只处理一次

```
##### 4、`include_once` 与 `require_once` 区别
```
确定只包含一次，如果已经包含，不会包含第二次
```
##### 5、`Memcached` 与 `Redis` 区别
```
1、Redis和Memcache都是将数据存放在内存中，都是内存数据库。不过memcache还可用于缓存其他东西，例如图片、视频等等；

2、Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，hash等数据结构的存储；

3、虚拟内存--Redis当物理内存用完时，可以将一些很久没用到的value 交换到磁盘；

4、过期策略--memcache在set时就指定，例如set key1 0 0 8,即永不过期。Redis可以通过例如expire 设定，例如expire name 10；

5、分布式--设定memcache集群，利用magent做一主多从;redis可以做一主多从。都可以一主一从；

6、存储数据安全--memcache挂掉后，数据没了；redis可以定期保存到磁盘（持久化）；

7、灾难恢复--memcache挂掉后，数据不可恢复; redis数据丢失后可以通过aof恢复；

8、Redis支持数据的备份，即master-slave模式的数据备份；
```
##### 6、`MySQL` 各个存储引擎、及区别（一定会问 `MyISAM` 与 `Innodb` 区别）
```
1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一;

2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败;

3. InnoDB 是聚集索引，MyISAM 是非聚集索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
如何选择：
1. 是否要支持事务，如果要请选择 InnoDB，如果不需要可以考虑 MyISAM;

2. 如果表中绝大多数都只是读查询，可以考虑 MyISAM，如果既有读写也挺频繁，请使用InnoDB;

3. 系统奔溃后，MyISAM恢复起来更困难，能否接受，不能接受就选 InnoDB;

4. MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM)，说明其优势是有目共睹的。如果你不知道用什么存储引擎，那就用InnoDB，至少不会差。
```
##### 7、`HTTP` 与 `HTTPS` 区别
```
1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
```
##### 8、`Apache` 与 `Nginx` 区别
```
(1)nginx相对于apache的优点：

* 轻量级，同样起web服务，比apache占用更少的内存及资源

* 抗并发，nginx处理请求是异步非阻塞的，而apache是阻塞型的

在高并发下，nginx能保持低资源低消耗高性能

* 高度模块化的设计，编写模块相对简单

(2)apache相对于nginx的优点：

* Rewrite比nginx的rewrite强大   ###rewrite的主要功能就是实现统一资源定位符（URL）的跳转

* 模块多，基本想到的都可以找到

* 少bug，nginx的bug相对较多

* 超稳定

存在的理由：一般来说，需要性能的web服务，用nginx。若不需要性能只求稳定，就选用apache。

2、作为web服务器：

相比apache，nginx使用更少的资源，支持更多的并发连接，体现更高的效率。

Nginx作为负载均衡服务器：nginx既可以在内部直接支持rails和php程序对外进行服务，也可以支持http代理服务器对外进行服务。Nginx采用C进行编写，不论是系统资源开销还是CPU使用效率都比较好。

作为邮件代理服务器：最早开发这个产品的目的之一也是作为邮件代理服务器。

3、nginx配置简洁， apache较复杂

Nginx静态处理性能比apache高3倍以上

4、最核心的区别在于：apache是同步多进程模型，一个连接对应一个进程，nginx是异步的，多个连接可以对应一个进程。

Nginx处理静态文件好，耗费内存少，只适合静态和反向。Apache在处理动态有优势，nginx并发性比较好，CPU占用内存低，如果rewrite频繁，选用apache最佳。

总的来说，apache依然是大部分公司的首选
```
##### 9、`define()` 与 `const` 区别
```
1.const是一种语言结构，而define是一个函数。

2.const可以在类中使用，而define不可以。在PHP5.3以前，const只能在类中使用，而PHP5.3开始在类外也可以使用。

3.const不能在条件分支中使用，而define可以。

4.const只能用普通的常量名称，define可以使用表达式。

5.const在PHP5.6之前只接受静态的标量，从PHP5.6开始可以使用表达式，define可以使用表达式。

6.const定义的常量是大小写敏感的，而define可以通过第三个参数来指定是否大小写敏感（true不敏感；false敏感，默认为false）。

7.const定义常量时考虑命名空间，而define不会。简单来说就是const可以在不同的命名空间下定义同名的常量，而define则不可以。
```
##### 10、`traits` 与 `interfaces` 区别 及 `traits` 解决了什么痛点？
```
1、trait看上去更像是为了代码的复用而写的一个小插件，它类似于include，可以用use放在类中间，让trait里面定义的方法作为class的一部分，本身不能直接实例化。

2、interface里面的方法都是虚拟的，需要在继承的时候对这些方法进行重定义。也就是说，方法是说明性质的，并没有实际操作，而你在继承的时候，需要实现这些方法，不然就会出错，而且不能缺失。interface经常用于架构的时候，对一个实例所拥有的属性和方法进行抽象定义。简单来讲类似一个协议，是老板下达的任务。你要继承的话，必须满足这个协议，也就是完成老板下达的任务。
```
##### 11、`Git` 与 `SVN` 区别
```
1.SVN属于集中化的版本控制系统，有个不太精确的比喻:SVN = 版本控制+ 备份服务器。

SVN使用起来有点像是档案仓库的感觉，支持并行读写文件，支持代码的版本化管理，功能包括取出、导入、更新、分支、改名、还原、合并等。

Git是一个分布式版本控制系统，操作命令包括：clone，pull，push,branch ,merge ,push,rebase，Git擅长的是程序代码的版本化管理。

2.GIT跟SVN一样有自己的集中式版本库或服务器。但GIT更倾向于被使用于分布式模式，也就是每个开发人员从中心版本库/服务器上chect out代码后会在自己的机器上克隆一个自己的版本库。

可以这样说，如果你被困在一个不能连接网络的地方时，就像在飞机上，地下室，电梯里等，你仍然能够提交文件，查看历史版本记录，创建项目分支，等。对一些人来说，这好像没多大用处，但当你突然遇到没有网络的环境时，这个将解决你的大麻烦。

3.GIT把内容按元数据方式存储，而SVN是按文件所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。如果你把.git目录的体积大小跟.svn比较，你会发现它们差距很大。

因为.git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。

4.分支在SVN中一点不特别，就是版本库中的另外的一个目录。如果你想知道是否合并了一个分支，你需要手工运行像这样的命令svn propget svn:mergeinfo，来确认代码是否被合并。

然而，处理GIT的分支却是相当的简单和有趣。你可以从同一个工作目录下快速的在几个分支间切换。你很容易发现未被合并的分支，你能简单而快捷的合并这些文件。

5.GIT没有一个全局的版本号，而SVN有。
目前为止这是跟SVN相比GIT缺少的最大的一个特征。你也知道，SVN的版本号实际是任何一个相应时间的源代码快照。

我认为它是从CVS进化到SVN的最大的一个突破。因为GIT和SVN从概念上就不同，我不知道GIT里是什么特征与之对应。

6.GIT的内容完整性要优于SVN：
GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏
```
#### 数据库篇

##### 1、MySQL
- 索引、联合索引（命中条件）
```
索引是存储引擎用于快速找到记录的一种数据结构,对经常使用增删改的数据表、或者重复率较高的字段、或者表记录较少的情况下尽量不使用索引
索引创建
ALTER TABLE `table_name` ADD INDEX index_name (`column`); #普通索引
ALTER TABLE `table_name` ADD UNIQUE (`column`); #唯一索引
ALTER TABLE `table_name` ADD PRIMARY KEY (`column`); #主键索引
ALTER TABLE `table_name` ADD FULLTEXT (`column`); #全文索引
ALTER TABLE `table_name` ADD INDEX index_name (`column1`, `column2`, `column3`); #组合索引

索引区别
普通索引：最基本的索引，没有任何限制
唯一索引：与"普通索引"类似，不同的就是：索引列的值必须唯一，但允许有空值
主键索引：它是一种特殊的唯一索引，不允许有空值
全文索引：仅可用于 MyISAM 表，针对较大的数据，生成全文索引很耗时好空间
组合索引：为了更多的提高 MySQL 效率可建立组合索引，遵循"最左前缀"原则
联合索引：又称复合索引，如果同一张表的两个字段一起作为查询条件次数比较多的情况下，使用联合索引效率更高
```
- 分库分表（水平分表、垂直分表）
- 分区
- 会使用 `explain` 分析 `SQL` 性能问题，了解各参数含义
- `Slow Log`（有什么用，什么时候需要）
- 重点理解 `type、rows、key`
- `CRUD`
- `JOIN、LEFT JOIN 、RIGHT JOIN、INNER JOIN`
- `UNION`
- `GROUP BY + COUNT + WHERE` 组合案例
- 常用 `MySQL` 函数，如：`now()`、`md5()`、`concat()`、`uuid()`等
- 1:1、1:n、n:n 各自适用场景
- 了解触发器是什么，说个使用场景
- 数据库优化手段
- `MSSQL`(了解)
- 查询最新5条数据
- 从user表随机调取10条数据
```
select * from user where rand() limit 10;
```
##### 2、NOSQL
- 持久化
- 支持多钟数据类型
- 可利用 `CPU `多核心
- 内存淘汰机制
- 集群 `Cluster`
- 支持 `SQL`
- 性能对比
- 支持事务
- 应用场景
- `Redis、Memcached、MongoDB`
- 对比、适用场景（可从以下维度进行对比）
- 你之前为了解决什么问题使用的什么，为什么选它？
#### 服务器篇

##### 1、查看 `CPU`、内存、时间、系统版本等信息
##### 2、`find` 、`grep` 查找文件
##### 3、`awk` 处理文本
##### 4、查看命令所在目录
##### 5、自己编译过 `PHP `吗？如何打开` readline `功能
##### 6、如何查看 `PHP` 进程的内存、`CPU` 占用
##### 7、如何给 `PHP` 增加一个扩展
##### 8、修改 `PHP Session` 存储位置、修改 `INI` 配置参数
##### 9、负载均衡有哪几种，挑一种你熟悉的说明其原理
##### 10、数据库主从复制 `M-S` 是怎么同步的？是推还是拉？会不会不同步？怎么办
##### 11、如何保障数据的可用性，即使被删库了也能恢复到分钟级别。你会怎么做。
##### 12、数据库连接过多，超过最大值，如何优化架构。从哪些方便处理？
##### 13、`502 `大概什么什么原因？如何排查 `504`呢？
#### 架构篇

##### 1、偏运维（了解）：
- 负载均衡（`Nginx、HAProxy、DNS`）
- 主从复制（`MySQL、Redis`）
- 数据冗余、备份（MySQL增量、全量 原理）
- 监控检查（分存活、服务可用两个维度）
- `MySQL、Redis、Memcached Proxy 、Cluster` 目的、原理
- 分片
- 高可用集群
- `RAID`
- 源代码编译、内存调优
##### 2、缓存
- 工作中遇到哪里需要缓存，分别简述为什么
##### 3、搜索解决方案
##### 4、性能调优
##### 5、各维度监控方案
##### 6、日志收集集中处理方案
##### 7、国际化
##### 8、数据库设计
##### 9、静态化方案
##### 10、画出常见 `PHP` 应用架构图
#### 框架篇

##### 1、`ThinkPHP（TP）、CodeIgniter（CI）、Zend`（非 `OOP` 系列）
##### 2、`Yaf、Phalcon`（`C` 扩展系）
##### 3、`Yii、Laravel、Symfony`（纯 `OOP `系列）
##### 4、`Swoole、Workerman` （网络编程框架）
##### 5、对比框架区别几个方向点
- 是否纯 `OOP`
- 类库加载方式（自己写 `autoload` 对比 `composer` 标准）
- 易用性方向（`CI` 基础框架，`Laravel` 这种就是高开发效率框架以及基础组件多少）
- 黑盒（相比 `C` 扩展系）
- 运行速度（如：`Laravel` 加载一大堆东西）
- 内存占用
#### 设计模式

##### 1、单例模式（重点）
##### 2、工厂模式（重点）
##### 3、观察者模式（重点）
##### 4、依赖注入（重点）
##### 5、装饰器模式
##### 6、代理模式
##### 7、组合模式
#### 安全篇

##### 1、`SQL` 注入
```
SQL注入攻击指的是用户或者黑客通过构建特殊的输入作为参数传入我们的Web应用程序端，而这些输入大都是SQL语法里的一些组合，通过执行SQL语句进而执行攻击者所要的操作，其主要原因是程序员没有细致地过滤用户输入的数据，致使非法数据侵入系统而造成的。因此我们在做开发过程中一定要预防sql注入，主要从两方面着手：

1、占位符的方式，就是对sql语句进行预处理，然后执行sql语句

2、通过addslashes或者mysql_real_escape_string这两个函数对用户输入的值进行转义处理，把一些特殊的字符转义掉。
```
##### 2、`XSS` 与 `CSRF`
```
CSRF:https://baike.baidu.com/item/CSRF/2735433
防范方式: CSRF TOKEN, 即提交表单时同时提交一段由服务端渲染表单时生成的token,通过校验token来防范csrf攻击

XSS:https://baike.baidu.com/item/xss/917356
简单来说,XSS就是正常页面执行了用户或黑客提交的前端代码,比如你用了eval('这里执行了用户提交的代码'),
或者你的页面正常解析了用户提交的html代码,如用户提交的个人信息是:<img src="广告连接"><script>window.href="恶意网站连接"</script>,
而你不加过滤转义就入库,然后页面正常解析html代码,最终用户访问这个页面就会跳转到恶意网站 ,这就是XSS
防范方式: 过滤&&转义用户输入(如htmlentities、htmlspecialchars),永久不要信任客户端
```
##### 3、输入过滤
##### 4、`Cookie` 安全
##### 5、禁用 `mysql_` 系函数
##### 6、数据库存储用户密码时，应该是怎么做才安全
##### 7、验证码 `Session` 问题
##### 8、安全的 `Session ID` （让即使拦截后，也无法模拟使用）
##### 9、目录权限安全
##### 10、包含本地与远程文件
##### 11、文件上传 `PHP` 脚本
##### 12、`eval` 函数执行脚本
##### 13、`disable_functions` 关闭高危函数
##### 14、`FPM` 独立用户与组，给每个目录特定权限
##### 15、了解 `Hash` 与 `Encrypt` 区别
#### 高阶篇

##### 1、`PHP` 数组底层实现 （`HashTable` + `Linked` `list`）
##### 2、`Copy on write` 原理，何时 `GC`
##### 3、`PHP` 进程模型，进程通讯方式，进程线程区别
##### 4、`yield` 核心原理是什么
##### 5、`PDO prepare` 原理
##### 6、`PHP 7` 与 `PHP 5` 有什么区别
##### 7、`Swoole` 适用场景，协程实现方式
#### 前端篇

##### 1、原生获取 `DOM` 节点，属性
##### 2、盒子模型
##### 3、`CSS` 文件、`style` 标签、行内 `style` 属性优先级
##### 4、`HTML` 与 `JS` 运行顺序（页面 `JS` 从上到下）
##### 5、`JS` 数组操作
##### 6、类型判断
##### 7、`this` 作用域
##### 8、`.map()` 与 `this` 具体使用场景分析
##### 9、`Cookie` 读写
##### 10、`JQuery` 操作
##### 11、`Ajax` 请求（同步、异步区别）随机数禁止缓存
##### 12、`Bootstrap` 有什么好处
##### 13、跨域请求 N 种解决方案
##### 14、新技术（了解）
- `ES6`
- 模块化
- 打包
- 构建工具
- `vue、react、webpack`、
- 前端 mvc
##### 15、优化
- 浏览器单域名并发数限制
- 静态资源缓存 304 （`If-Modified-Since` 以及 `Etag` 原理）
- 多个小图标合并使用 `position` 定位技术 减少请求
- 静态资源合为单次请求 并压缩
- `CDN`
- 静态资源延迟加载技术、预加载技术
- `keep-alive`
- `CSS` 在头部，`JS` 在尾部的优化（原理）
#### 网络篇

##### 1、`IP` 地址转 `INT`
##### 2、`192.168.0.1/16` 是什么意思
##### 3、`DNS` 主要作用是什么？
##### 4、`IPv4` 与 `v6` 区别
#### 网络编程篇

##### 1、`TCP` 三次握手流程
```
三次握手 客户端：我要和你通信(syn-sent) 服务端：你的请求已收到，发送确认(syn-rcvd) 客户端：你的确认已收到，连接建立(est)

四次挥手 客户端：我没有东西了，准备关闭(fin-wait) 服务端：你的关闭我收到了，但我还有点东西没传完(close-wait) ……一段时间后…… 服务端：我的东西传完了，可以关闭了(last-ack) 客户端：收到关闭通知，你也可以关闭了(time-wait)
```
##### 2、`TCP`、`UDP` 区别，分别适用场景
##### 3、有什么办法能保证 `UDP` 高可用性(了解)
##### 4、`TCP` 粘包如何解决？
##### 5、为什么需要心跳？
##### 6、什么是长连接？
##### 7、`HTTPS` 是怎么保证安全的？
##### 8、流与数据报的区别
##### 9、进程间通信几种方式，最快的是哪种？
##### 10、`fork()` 会发生什么？
#### API 篇

##### 1、`RESTful` 是什么
##### 2、如何在不支持 `DELETE` 请求的浏览器上兼容 `DELETE` 请求
##### 3、常见 `API` 的 A`PP_ID APP_SECRET` 主要作用是什么？阐述下流程
##### 4、`API` 请求如何保证数据不被篡改？
##### 5、`JSON` 和 `JSONP` 的区别
##### 6、数据加密和验签的区别
##### 7、`RSA` 是什么
##### 8、`API` 版本兼容怎么处理
##### 9、限流（木桶、令牌桶）
##### 10、`OAuth 2` 主要用在哪些场景下
##### 11、`JWT`
##### 12、`PHP` 中 `json_encode(['key'=>123]);` 与 `return json_encode([]);` 区别，会产生什么问题？如何解决
